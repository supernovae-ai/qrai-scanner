# QRAISC v0.2 Implementation Plan

## Overview

This plan outlines the v0.2 roadmap based on performance analysis and research conducted on the QRAISC codebase.

## Completed Quick Wins (v0.1.x)

| Optimization | Impact | Status |
|-------------|--------|--------|
| Single image load in validate() | 5-15% on decode-heavy images | ✅ Done |
| Conditional rqrr after rxing | ~50% decode time when rxing succeeds | ✅ Done |
| Single-pass channel extraction | 4x faster channel extraction | ✅ Done |
| Raw buffer operations | Reduced function call overhead | ✅ Done |

---

## v0.2.0 - Async & Batch APIs

### Priority 1: Async Validation API

**Goal**: Non-blocking validation for Node.js/web applications

**Implementation**:

```rust
// New async API using tokio
pub async fn validate_async(image_bytes: &[u8]) -> Result<ValidationResult> {
    let bytes = image_bytes.to_vec();
    tokio::task::spawn_blocking(move || validate(&bytes)).await?
}

// Node.js with napi-rs AsyncTask
#[napi]
pub async fn validate_async(buffer: Buffer) -> Result<ValidationResult> {
    // Uses AsyncTask pattern for true async
}
```

**Files to modify**:
- `crates/qraisc-core/src/lib.rs` - Add async wrappers
- `crates/qraisc-node/src/lib.rs` - Add `#[napi(async)]` exports
- `Cargo.toml` - Add tokio as optional dependency

### Priority 2: Batch Validation API

**Goal**: Efficient processing of multiple images with parallelism

**Implementation**:

```rust
/// Validate multiple images in parallel
pub fn validate_batch(images: &[&[u8]]) -> Vec<Result<ValidationResult>> {
    images.par_iter()
        .map(|img| validate(img))
        .collect()
}

/// Batch with progress callback
pub fn validate_batch_with_progress<F>(
    images: &[&[u8]],
    on_progress: F
) -> Vec<Result<ValidationResult>>
where
    F: Fn(usize, usize) + Sync
```

**Node.js**:

```typescript
// Parallel batch validation
validateBatch(buffers: Buffer[]): Promise<ValidationResult[]>

// With progress callback
validateBatchWithProgress(
  buffers: Buffer[],
  onProgress: (completed: number, total: number) => void
): Promise<ValidationResult[]>
```

### Priority 3: Custom Stress Test Configuration

**Goal**: Allow users to configure which stress tests to run

```rust
#[derive(Default)]
pub struct ValidationConfig {
    /// Run original decode test (default: true)
    pub test_original: bool,
    /// Run 50% downscale test (default: true)
    pub test_downscale_50: bool,
    /// Run 25% downscale test (default: true)
    pub test_downscale_25: bool,
    /// Run light blur test (default: true)
    pub test_blur_light: bool,
    /// Run medium blur test (default: true)
    pub test_blur_medium: bool,
    /// Run low contrast test (default: true)
    pub test_low_contrast: bool,
    /// Custom score weights
    pub custom_weights: Option<ScoreWeights>,
}

pub fn validate_with_config(
    image_bytes: &[u8],
    config: &ValidationConfig
) -> Result<ValidationResult>
```

---

## v0.2.1 - WebAssembly Target

### WASM Optimization Strategy

Based on research, key optimizations for WASM:

1. **Use rqrr over rxing for WASM**
   - rqrr is ~5x faster in WASM due to simpler code
   - rxing has too many dependencies that bloat WASM bundle

2. **SIMD operations** (when available)
   - Use `wasm-simd` feature for parallel pixel operations
   - Target ~51ms decode time (vs ~200ms without SIMD)

3. **Bundle size optimization**
   - Target < 500KB gzipped
   - Use `wasm-opt` for optimization passes
   - Strip debug symbols in release

**Implementation**:

```toml
# Cargo.toml
[target.'cfg(target_arch = "wasm32")'.dependencies]
rqrr = "0.6"

[features]
default = []
wasm = ["rqrr", "wasm-bindgen"]
wasm-simd = ["wasm", "wide"] # SIMD operations
```

**Build command**:
```bash
wasm-pack build --target web --release
wasm-opt -O3 -o optimized.wasm pkg/qraisc_bg.wasm
```

---

## v0.3.0 - Future Enhancements

### ML Preprocessing Hints

```rust
/// Suggest preprocessing parameters based on image analysis
pub fn suggest_preprocessing(img: &DynamicImage) -> PreprocessingSuggestion {
    // Analyze histogram, color distribution, contrast
    // Return optimal parameters for this specific image
}
```

### QR Region Detection

```rust
/// Detect and crop QR code region from larger image
pub fn detect_qr_region(img: &DynamicImage) -> Option<Rectangle> {
    // Use finder pattern detection
    // Return bounding box
}
```

### Multi-QR Detection

```rust
/// Detect all QR codes in an image
pub fn decode_all(img: &DynamicImage) -> Vec<DecodeResult> {
    // Return all QR codes found
}
```

---

## Testing Strategy

### New Test Categories

1. **Async tests**: Verify async APIs don't block event loop
2. **Batch tests**: Verify parallel processing correctness
3. **WASM tests**: Browser-based testing with wasm-bindgen-test
4. **Config tests**: Verify custom configurations work correctly

### Benchmarks

```bash
# Run async benchmarks
cargo bench --features async

# Run WASM benchmarks
wasm-pack test --headless --chrome
```

---

## Timeline

| Phase | Features | Target |
|-------|----------|--------|
| v0.2.0 | Async API, Batch API, Custom config | Q1 2025 |
| v0.2.1 | WASM target | Q1 2025 |
| v0.3.0 | ML hints, Region detection, Multi-QR | Q2-Q3 2025 |

---

## Migration Guide

### From v0.1.x to v0.2.0

```rust
// v0.1.x - sync only
let result = validate(&bytes)?;

// v0.2.0 - async available
let result = validate_async(&bytes).await?;

// v0.2.0 - batch processing
let results = validate_batch(&[&bytes1, &bytes2, &bytes3]);
```

### Node.js

```typescript
// v0.1.x - sync only
const result = validate(buffer);

// v0.2.0 - async available
const result = await validateAsync(buffer);

// v0.2.0 - batch with progress
const results = await validateBatchWithProgress(
  buffers,
  (done, total) => console.log(`${done}/${total}`)
);
```
