# qraisc-node - Node.js Bindings

Native Rust bindings for Node.js via napi-rs.

## Architecture

```
TON CODE                    NAPI-RS                         RUST
────────────────────────────────────────────────────────────────────
validate(buffer)    →    index.js detecte OS    →    core_validate()
     ↓                        ↓                           ↓
 Buffer JS          →    Convertit en &[u8]    →    Traite l'image
     ↓                        ↓                           ↓
 Objet JS           ←    Convertit struct      ←    ValidationResult
────────────────────────────────────────────────────────────────────
```

## How napi-rs Works

### 1. Rust Code (`src/lib.rs`)

The `#[napi]` macro exposes Rust functions to Node.js:

```rust
#[napi]  // ← Generates FFI bindings automatically
pub fn validate(image_buffer: Buffer) -> Result<ValidationResult> {
    let result = core_validate(&image_buffer)?;
    Ok(ValidationResult { ... })
}
```

**What `#[napi]` does:**
- Generates C/FFI code to communicate with Node.js N-API
- Converts JS `Buffer` ↔ Rust `&[u8]` automatically
- Converts Rust structs → JS objects

### 2. Build Process (`npm run build`)

```
lib.rs + #[napi]  →  cargo + napi-rs  →  qrai-scanner.darwin-arm64.node
```

The `.node` file is a **native binary** (~2MB) that Node.js can load directly.

### 3. JavaScript Loader (`index.js`)

Auto-generated by napi-rs. Detects OS/arch and loads the correct binary:

```javascript
switch (platform) {
  case 'darwin':
    switch (arch) {
      case 'arm64':
        nativeBinding = require('./qrai-scanner.darwin-arm64.node')
      case 'x64':
        nativeBinding = require('./qrai-scanner.darwin-x64.node')
    }
  case 'linux': ...
  case 'win32': ...
}

module.exports.validate = nativeBinding.validate
```

### 4. Type Definitions (`index.d.ts`)

Auto-generated TypeScript definitions for all exported functions.

## Files

| File | Purpose | Generated? |
|------|---------|------------|
| `src/lib.rs` | Rust source with `#[napi]` exports | No |
| `Cargo.toml` | Rust dependencies (napi, napi-derive) | No |
| `package.json` | npm config + napi-rs settings | No |
| `build.rs` | napi-rs build script | No |
| `index.js` | Platform-aware loader | Yes |
| `index.d.ts` | TypeScript definitions | Yes |
| `*.node` | Native binaries per platform | Yes |

## Commands

```bash
npm install        # Install @napi-rs/cli
npm run build      # Compile Rust → .node (release)
npm run build:debug # Compile debug build (faster, larger)
node test-ok.mjs   # Run integration test
```

## Adding New Functions

1. Add function in `src/lib.rs` with `#[napi]`:

```rust
#[napi]
pub fn my_function(input: Buffer) -> Result<String> {
    // ...
}
```

2. Rebuild: `npm run build`

3. Function is auto-exported in `index.js` and typed in `index.d.ts`

## Supported Platforms

Configured in `package.json` under `napi.triples`:

| Platform | Architecture | Binary |
|----------|--------------|--------|
| macOS | arm64 (M1/M2/M3) | `qrai-scanner.darwin-arm64.node` |
| macOS | x64 (Intel) | `qrai-scanner.darwin-x64.node` |
| Linux | x64 (glibc) | `qrai-scanner.linux-x64-gnu.node` |
| Linux | x64 (musl) | `qrai-scanner.linux-x64-musl.node` |
| Linux | arm64 | `qrai-scanner.linux-arm64-gnu.node` |
| Windows | x64 | `qrai-scanner.win32-x64-msvc.node` |

## Local Development

No npm registry needed. The `.node` binary is compiled locally:

```bash
# In another project
npm install ../qrai-scanner/crates/qraisc-node

# Or with npm link
cd crates/qraisc-node && npm link
cd your-project && npm link @supernovae/qrai-scanner
```

## Key Dependencies

| Crate | Purpose |
|-------|---------|
| `napi` | N-API bindings for Rust |
| `napi-derive` | Procedural macros (`#[napi]`) |
| `napi-build` | Build script helpers |
| `qraisc-core` | Core QR validation logic |

## Performance

Native Rust speed, no JavaScript overhead for computation:

| Operation | Time |
|-----------|------|
| `decode()` | ~20ms |
| `validateFast()` | ~50ms |
| `validate()` | ~80ms |
